#!/bin/bash

### TODO
#
# - Understand how partial transferring works. Look into `--append-verify', `--partial' and `--partial-dir' in particular.
# - Implement bash autocompletion of target arguments.
#   Look at: http://tldp.org/LDP/abs/html/tabexpansion.html
#

### Configuration

export RSYNC_PASSWORD=XXXX
export RSYNC_PARTIAL_DIR=.rsync_partial

log_filepath=/var/log/rsync.log
daemon_host=nastynas
module_prefix=nondsm_ # Necessary in order to match the rsyncd modules I wrote instead of those Synology DSM created based on the Shared Folders.
dest_basepath=/volume1
base_opts="--log-file=$log_filepath\
           --itemize-changes\
           --verbose\
           --archive\
           --update\
           --delete"
targets=(ALL books films music other photos series shows videos beets) # Note that with this way of defining an array, spaces cannot be used in target names.
date_format='+%Y/%m/%d %H:%M'


### Function definitions

backup_target() {
    local target=$1 

    if   [[ "$target" == books?(/) ]]
    then
        opts="$base_opts --whole-file"
    elif [[ "$target" == films?(/) ]]
    then
        opts="$base_opts --partial"
    elif [[ "$target" == music?(/) ]]
    then
        opts="$base_opts --whole-file"
    elif [[ "$target" == other?(/) ]]
    then
        opts="$base_opts --whole-file"
    elif [[ "$target" == photos?(/) ]]
    then
        opts="$base_opts --whole-file"
    elif [[ "$target" == series?(/) ]]
    then
        opts="$base_opts --partial"
    elif [[ "$target" == shows?(/) ]]
    then
        opts="$base_opts --partial"
    elif [[ "$target" == videos?(/) ]]
    then
        opts="$base_opts --whole-file"
    elif [[ "$target" == beets?(/) ]]
    then
        dest_basepath=$HOME/.config
        opts="$base_opts --whole-file --copy-links"
    else
        echo "[`date "$date_format"`] ERROR: Unknown target name was specified." >> $log_filepath
        exit 1
    fi

    echo "Running:"
    echo rsync $opts $daemon_host::$module_prefix$target/ $dest_basepath/$target
    rsync $opts $daemon_host::$module_prefix$target/ $dest_basepath/$target
}

backup_all() {
    for target in ${targets[@]} # No error handling necessary since these targets are the valid ones by definition.
    do
        if [ $target == "ALL" ]
        then
            continue
        else
            backup_target $target
        fi
    done
}


# Help message

if [ -z "$1" ] || [ "$1" == "--help" ] || [ "$1" == "-h" ]
then
    cat <<EOF
Specialized backup script which builds rsync client calls to the configured daemon for each specified target.
USAGE: $0 [--dry-run] TARGET_NAMES

  --dry-run       If supplied, all specified rsync instances will be run in dry run mode.
  TARGET_NAMES    Space-separated names of targets to backup, at least one needs to be specified.
                  Valid target names are:
EOF
    for target in ${targets[@]}
    do
        echo "                      $target"
    done

    cat <<EOF
                  Note the special target name ALL, which makes the script loop through all valid targets.
                  In case this one is specified, no target names specified after it will be processed.

See source code for configuration of rsync options and the logfile location.
EOF
    exit 0
fi


# Dry run?

if [ "$1" == "--dry-run" ]
then
    base_opts+=" --dry-run"
    shift
fi


# Main

for target
do
    is_valid_target=false
    for valid_target in ${targets[@]}
    do
        if    [[ "$target" == $valid_target?(/) ]]
        then
            is_valid_target=true
            if [ "$target" == "ALL" ] # if the ALL target was encountered, don't process anything else and exit succesfully
            then
                backup_all
                exit 0
            else
                backup_target $target
            fi
        else
            continue
        fi
    done

    if [ "$is_valid_target" = false ]
    then
        echo "[`date "$date_format"`] ERROR: Invalid target name '$target' was specified." >> $log_filepath
    fi
done
